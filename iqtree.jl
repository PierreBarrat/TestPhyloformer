#!/bin/bash
#=
exec julia -O0 --compile=min --startup-file=no "${BASH_SOURCE[0]}" "$@"
=#

using Random, ArgParse
using TreeTools

iqtree_bin = "$(homedir())/miniconda3/envs/nextstrain/bin/iqtree"
cleanup_extensions = (
	"bionj",
	"ckp.gz",
	"contree",
	"iqtree",
	"mldist",
	"model.gz",
	"nex",
	"phy",
	"treefile",
	"log",
	"boottrees",
)

function main()
	args = parse_cmd()

	# iqtree inference
	bootstrap = args["bootstrap"] >= 0
	bootstrap_type = args["standard-bootstrap"] ? :std : :ufb
	if bootstrap
		if bootstrap_type == :ufb
			println("Running iqtree with ultrafast bootstrap `-bb 1000`")
		elseif bootstrap_type == :std
			println("Running iqtree with standard bootstrap `-b 100`")
		end
	end
	shalrt = args["alrt"]
	# Need to change function that parses bb values when used with alrt
	@assert !(shalrt && args["bootstrap"] > 0) "Cannot use both SH-aLRT and bootstrap>0 for now. Use `--bootstrap 0` and prune low confidence branches manually"
	shalrt && println("Using SH-aLRT test with `-alrt 1000`")

	t = @elapsed iqtree(
		args["alignment"], args["outfile"], args["iqtree-options"];
		cleanup=args["cleanup"], bootstrap, bootstrap_type, shalrt,
	)
	println("iqtree runtime: $(t)s")

	# Post processing
	tree = if bootstrap
		read_tree(args["outfile"]; force_new_labels=true)
	else
		read_tree(args["outfile"])
	end

	## Deleting short branches
	if args["delete-null-branches"] != 0
		L = args["delete-null-branches"]
		# delete_null_branches(args["outfile"], args["delete-null-branches"])
		println("Deleting branches shorter than $(1/L/2)")
		TreeTools.delete_null_branches!(tree, threshold=1/L/2)
	end
	## Deleting low bootstrap branches
	if args["bootstrap"] > 0
		remove_low_bootstrap!(tree, args["bootstrap"])
	end

	## Rerooting
	if args["root"] != ""
		r = args["root"]
		if !haskey(tree.lnodes, r)
			display(tree.lnodes)
			error("Cannot root on node $(r): not found in tree.")
		end
		if tree.lnodes[r].isleaf
			println("Rerooting on the ancestor of $r")
			TreeTools.root!(tree, tree[r].anc.label)
		else
			println("Rerooting on $r")
			TreeTools.root!(tree, r)
		end
	end

	# Write output
	write_newick(args["outfile"], tree)

	# Labelling nodes
	if !args["no-internal-node-label"] && !bootstrap
		println("Labelling internal nodes...")
		label_internal_nodes(args["outfile"])
	end
end 

function parse_cmd()
	s = ArgParseSettings()
	@add_arg_table! s begin
		"--alignment", "--aln"
			help = "Input alignment (fasta)"
			required=true
		"--outfile", "-o"
			help = "Output newick file"
			required=true
		"--iqtree-options"
			help = "String with iqtree options"
			arg_type = String
			default = ""
		"--cleanup"
			help = "Remove files generated by iqtree with extensions in `$(cleanup_extensions)`."
			action = :store_true
		"--bootstrap"
			help = "Remove branches with bootstrap value lower than the one given. A negative value does not trigger the bootstrap calculation. A value of 0 triggers it without removing any branches."
			arg_type = Int
			default = -1
		"--standard-bootstrap"
			help = "Used standard bootstrap instead of ultrafast bootstrap. Only had an effect if the --bootstrap option is used."
			action = :store_true
		"--alrt"
			help = "SH-aLRT test. Labels the branches with the calculated confidence, but does not remove them."
			action = :store_true
		"--root"
			help = "Set node as root"
			arg_type = String
			default = ""
		"--delete-null-branches"
			help = "With non-zero arg `L`: remove branches shorter than `1/L/2`. If 0., keep all branches."
			arg_type = Float64
			default = 0.
		"--no-internal-node-label", "--label"
			help = "Remove labels of internal nodes (*e.g.*: 'NODE_23')"
			action = :store_true
	end
	return parse_args(s)
end

function iqtree(
	aln, outfile, iqtree_options::String;
	cleanup=true, bootstrap=false, bootstrap_type=:ufb, shalrt=false,
)
	# Getting outdir
	idx = findlast('/',outfile)
	outdir = !isnothing(idx) ? outfile[1:idx] : "./"
	# Getting indir
	idx = findlast('/',aln)
	indir = !isnothing(idx) ? aln[1:idx] : "./"

	# Escape dict for chars that iqtree modifies
	escape_dict = Dict(string(c)=>"_DELIM$(randstring(20))_" for c in "/|()*")
	rev_escape_dict = Dict(v=>k for (k,v) in escape_dict)
	
	# Replace special chars in sequence names
	aln_tmp = replace(aln, ".fasta"=>"-delim.fasta")
	open(aln_tmp, "w") do ofile
		for l in eachline(aln, keep=true)
			if l[1] == '>'
				tl = split(l, '|')[1]# * "\n"
				if tl[end] != '\n'
					tl *= "\n"
				end
				tl = replace(tl, r"[/|()*]" => s->escape_dict[s])
				write(ofile, tl)
			else
				write(ofile, l)
			end
		end
	end

	# Build command
	log_file = replace(aln_tmp, ".fasta"=>".fasta.log")
	cmd = "$(iqtree_bin) "
	# cmd *= " -czb "
	if bootstrap
		if bootstrap_type == :ufb
			cmd *= " -bb 1000 "
		elseif bootstrap_type == :std
			cmd *= " -b 100 "
		end
	end
	if shalrt
		cmd *= " -alrt 1000"
	end
	cmd *= iqtree_options
	cmd *= " -s $(aln_tmp) "

	#
	flag = :failed
	try
		println("Running $cmd")
		run(pipeline( Cmd(String.(split(cmd))), stdout=log_file ))

		# Dealing with outfile: replacing chars in sequence names
		tmp_outfile = outfile * "_tmp"
		treefile = if bootstrap && !shalrt # If only bootstrap was used, use the consensus
			# println("Using the consensus tree ", aln_tmp * ".contree")
			# aln_tmp * ".contree"
			## !! I was using the consensus tree until 12/05/22, but it seems to not be as good after all...
			println("Using the ML tree ", aln_tmp*".treefile")
			aln_tmp * ".treefile"
		else # Otherwise, the ML tree -- (the consensus tree does not have the aLRT)
			println("Using the ML tree ", aln_tmp*".treefile")
			aln_tmp*".treefile"
		end
		run(`cp $(treefile) $outfile`)
		for (k,v) in rev_escape_dict
			run(pipeline(`sed s'/'$(k)'/\'$(v)'/'g $outfile`, stdout=tmp_outfile))
			run(`cp $tmp_outfile $outfile`)
		end
		run(`rm $tmp_outfile`)
		flag = :success
		println("Tree building done: output in $outfile")
	catch err
		println("Tree building failed: log file $log_file")
		println(err)
	end

	# Replacing DELIM in bootstrap file
	# if bootstrap
	# 	cons_tree_file = aln_tmp * ".contree"
	# 	tmp_outfile = outfile * "_tmp"
	# 	for (k,v) in rev_escape_dict
	# 		run(
	# 			pipeline(`sed s'/'$(k)'/\'$(v)'/'g $bootstrap_file`;
	# 		 	stdout=tmp_boostrap_file)
	# 		 )
	# 		run(`cp $tmp_boostrap_file $bootstrap_file`)
	# 		run(`rm $tmp_boostrap_file`)
	# 	end
	# end

	# Cleanup
	if cleanup && flag == :success
		println("Cleaning up files...")
		run(`rm $aln_tmp`)
		cleanup_extensions
		for e in cleanup_extensions
			r = Regex("\\." * e)
			for f in readdir(outdir)
				if match(r, f) != nothing
					run(`rm $(outdir)$(f)`)
				end
			end
			for f in readdir(indir)
				if match(r, f) != nothing
					run(`rm $(indir)$(f)`)
				end
			end
		end
	end
	return cmd
end


function label_internal_nodes(nwkfile::AbstractString)
	t = read_tree(nwkfile) # Should label automatically
	write_newick(nwkfile, t)
end

function delete_null_branches(nwkfile::AbstractString, L)
	t = read_tree(nwkfile)
	TreeTools.delete_null_branches!(t, threshold=1/L/2)
	write_newick(nwkfile, t)
end
function unlabel_nodes!(t::Tree)
	for n in values(t.lnodes)
		if !n.isleaf
			n.label = "" # Not ideal - `read_tree` would benefit from an option to not label nodes. 
		end
	end
end

#=
WARNING
This fails when also using SHalrt ! labels are then of the form `76.1/87_RANDSTRING)
=#
function remove_low_bootstrap!(tree::Tree, bmin)

	for n in internals(tree)
		if !n.isroot
			bs = tryparse(Int, split(n.label, "__")[1])
			# bs value can be nothing if duplicate sequences are in the sample
			# this seems like an iqtree issue
			if !isnothing(bs) && bs < bmin
				delete_node!(n)
			elseif isnothing(bs)
				n.label = "100"
			end
		end
	end
	node2tree!(tree, tree.root; force_new_labels=true)
end

function parse_splits_file(splitsfile)
	strains = Dict{Int, String}()
	split_support = Dict{Vector{Int}, Int}()

	flag = :end
	open(splitsfile, "r") do f
		for line in eachline(f)
			flag = getflag(line, flag)

			if flag == :taxa # Integer identifier of each taxa "[id] 'name'"
				id = parse(Int, match(r"\[.*\]", line).match[2:end-1])
				name = String(match(r"\'.*\'", line).match[2:end-1])
				strains[id] = name

			elseif flag == :splits
				support = parse(Int, match(r"\t[0-9]*\t", line).match[2:end-1])
				p = match(r"\t .*,", line)
				sp = map(x->parse(Int, x), split(p.match[3:end-1], " "))
				split_support[sp] = support
			end

		end
	end

	return strains, split_support
end

function getflag(line, flag)
	if line == ";"
		flag = :end
	elseif line == "TAXLABELS"
		flag = :begin_taxa
	elseif line == "MATRIX"
		flag = :begin_splits
	elseif flag == :begin_splits
		flag = :splits
	elseif flag == :begin_taxa
		flag = :taxa
	end
	return flag
end
main()
